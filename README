http://groups.google.com/group/comp.programming.threads/browse_frm/thread/86718e3a31eba502/330720131d94fb5a?lnk=st&q=&rnum=14#330720131d94fb5a

http://www.lambdacs.com/cpt/FAQ.html

 Q397: Global signal handler dispatching to threads. 


>    I am fairleynew to threads. I have heard it mentioned that you can have
>a global signal handler which will disbatch signals to other threads in an
>app. I would like to know how this is achieved. I have tried adding a
>signall handler for each thread when it starts and they do not seem to
>recieve the signalls when I send them (via kill). I was Thinking if you kept
>track of all pid which got started you could then send them signals but as I
>stated earlier the threads doen't seem to recieve the signals. If someone
>could explain this with a simple code snippet I would appreciate it.

First off, since you didn't say what specific pthreads implementation
you're using, I'll be answering for POSIX; there are signal weirdnesses
in most (all?  probably not) implementations because it's hard to get
right, and some believe that the POSIX spec itself did not get some
things right.

Anyhow:  Signals and threads are an ugly mix.  You've got the
asynchronicity of threads multiplied by the asyncronicity and complex
rules (though a lot of people don't seem to know them) of signal
handlers.  Most high-performance thread implementations start doing
ugly things if you call threading functions inside signal handlers.

In POSIX threads, the signal disposition (i.e. handler) table is a
process resource.  Thus it is not possible to have different actions
for the same signal in different threads without a lot of hard,
probably non-portable, work.

The signal *mask* on the other hand (blocked signals) is per-thread,
so that each thread may indicate what signals may be delivered in its
context.

The easiest way to deal with signals in multithreaded systems is to
avoid them if at all possible.  Barring that, have the initialization
code block all signals before creating any threads, and have one thread
dedicated to doing sigwait() for interesting signals.  This removes
the (abnoxious?) multiplicitive asynchronicity.

Signal delivery in a POSIX environment is quite simple to describe,
but has lots of subtle consequences.  When a signal is generated 
asynchronously to a process (i.e. sent with kill(), sigqueue(), or
one of the POSIX.1b functions that can cause a signal to happen),
the following steps occur:

1.  If any thread is in a sigwait(), sigtimedwait() or sigwaitinfo(),
    that thread will synchronously "accept"[1] the signal.
2.  The system looks at the signal masks of all threads in the process,
    in unspecified (i.e. random) order, looking for a thread that has
    that signal unblocked.  The signal will be "delivered"[1] in the context
    of one of the threads that have the signal unblocked.
3.  If none of the threads are accepting the signal or have it unmasked,
    the signal will remain pending against the process, and the first
    thread that unmasks or accepts the signal will get it.

Now, for synchronous signals (i.e. those that are attributable to a
specific thread[2]) and signals sent via pthread_kill to a specific
thread, it's a slightly different story.  The signal is delivered
(or made pending) to that thread, and will only be deliverable (or
acceptable) from that thread.  Note also that blocking or SIG_IGNing
SIGFPE, SIGILL, SIGSEGV, or SIGBUS causes undefined behavior unless the
signal in question is generated by sigqueue(), kill(), or raise().

And finally, you asked about a global signal handler that dispatches to
other threads.  The way that one would implement that would be to have
a single thread sigwait()ing on everything, and when it gets one, does
some amount of magic to figure out what thread needs to be kicked, and
use some prearranged inter-thread mechanism (probably *not*
pthread_kill()!) to let the victim know.


There, did that make your head hurt?



[1] These are POSIX-defined terms.  The phases of a signal's lifetime
    are reasonably called out in POSIX.

[2] Whether alarm() expiration is attributable to a specific thread is
    up for some debate.  POSIX gives illegal instructions and touching
    invalid memory as examples of signals attributable to a specific
    thread.
